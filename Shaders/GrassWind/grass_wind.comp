#version 450

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Grass instance data structure
struct GrassInstance {
    mat4 modelMatrix;
    vec4 color;
    vec4 windData; // x: base height, y: flexibility, z: phase offset, w: unused
};

// Buffers
layout(std430, binding = 0) restrict buffer GrassBuffer {
    GrassInstance grassInstances[];
};

// Uniforms
layout(binding = 1) uniform WindUBO {
    vec4 windDirection;     // xyz: direction, w: strength
    vec4 windParams;        // x: time, y: frequency, z: turbulence, w: gustiness
    vec4 windWaves;         // x: wave1 freq, y: wave2 freq, z: wave1 amp, w: wave2 amp
} wind;

// Utility functions
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

vec3 getWindForce(vec3 position, float time) {
    // Base wind direction
    vec3 windDir = normalize(wind.windDirection.xyz);
    float windStrength = wind.windDirection.w;
    
    // Multi-layered wind waves
    float wave1 = sin(time * wind.windWaves.x + dot(position.xz, windDir.xz) * 0.1) * wind.windWaves.z;
    float wave2 = sin(time * wind.windWaves.y + dot(position.xz, windDir.xz) * 0.05) * wind.windWaves.w;
    
    // Turbulence using noise
    vec2 noisePos = position.xz * 0.1 + windDir.xz * time * 0.1;
    float turbulence = (noise(noisePos) - 0.5) * wind.windParams.z;
    
    // Gustiness - occasional stronger bursts
    float gustPhase = sin(time * 0.3 + hash(position.xz) * 6.28) * 0.5 + 0.5;
    float gust = pow(gustPhase, 4.0) * wind.windParams.w;
    
    // Combine all wind effects
    float totalStrength = windStrength * (1.0 + wave1 + wave2 + turbulence + gust);
    
    // Add some perpendicular variation for more natural movement
    vec3 perpendicular = vec3(-windDir.z, 0.0, windDir.x);
    vec3 variation = perpendicular * (wave2 * 0.3 + turbulence * 0.5);
    
    return (windDir + variation) * totalStrength;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    // Bounds check
    if (index >= grassInstances.length()) return;
    
    GrassInstance grass = grassInstances[index];
    
    // Extract original transform data
    mat4 originalMatrix = grass.modelMatrix;
    vec3 position = vec3(originalMatrix[3][0], originalMatrix[3][1], originalMatrix[3][2]);
    
    // Get wind data
    float baseHeight = grass.windData.x;
    float flexibility = grass.windData.y;
    float phaseOffset = grass.windData.z;
    
    // Calculate wind force at this position
    float time = wind.windParams.x + phaseOffset;
    vec3 windForce = getWindForce(position, time);
    
    // Calculate bend amount - taller grass bends more, more flexible grass bends more
    float bendFactor = flexibility * baseHeight * 0.5;
    
    // Create bending rotation based on wind force
    vec3 bendDirection = normalize(vec3(windForce.x, 0.0, windForce.z));
    float bendAngle = length(windForce.xz) * bendFactor * 0.1; // Scale down the angle
    
    // Limit maximum bend to prevent grass from bending too much
    bendAngle = min(bendAngle, radians(45.0));
    
    // Create rotation matrix for bending
    float cosAngle = cos(bendAngle);
    float sinAngle = sin(bendAngle);
    
    // Rotation around the perpendicular axis to bend direction
    vec3 rotAxis = normalize(cross(vec3(0.0, 1.0, 0.0), bendDirection));
    if (length(rotAxis) < 0.001) rotAxis = vec3(1.0, 0.0, 0.0); // Fallback
    
    // Rodrigues rotation formula
    mat3 rotMatrix = mat3(1.0) * cosAngle + 
                     outerProduct(rotAxis, rotAxis) * (1.0 - cosAngle) +
                     mat3(0.0, rotAxis.z, -rotAxis.y,
                          -rotAxis.z, 0.0, rotAxis.x,
                          rotAxis.y, -rotAxis.x, 0.0) * sinAngle;
    
    // Apply the rotation to the upper part of the matrix (preserving scale)
    mat4 windMatrix = originalMatrix;
    windMatrix[0] = vec4(rotMatrix * originalMatrix[0].xyz, originalMatrix[0].w);
    windMatrix[1] = vec4(rotMatrix * originalMatrix[1].xyz, originalMatrix[1].w);
    windMatrix[2] = vec4(rotMatrix * originalMatrix[2].xyz, originalMatrix[2].w);
    
    // Write back the modified matrix
    grassInstances[index].modelMatrix = windMatrix;
}
