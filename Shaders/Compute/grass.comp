#version 450
layout(local_size_x = 128) in; // bigger workgroup for better occupancy

layout(std430, set = 0, binding = 0) readonly buffer FixedMat4 {
    mat4 fixedMat4[];
};

layout(std430, set = 0, binding = 1) readonly buffer WindProps {
    vec4 windProps[];
};

layout(std430, set = 0, binding = 2) writeonly buffer GrassMat4 {
    mat4 grassMat4[];
};

layout(set = 0, binding = 3) uniform UniformTime {
    float elapsedTime;
};

// Fast approximation of sin (Taylor expansion)
float fastSin(float x) {
    const float B = 4.0 / 3.14159265;
    const float C = -4.0 / (3.14159265 * 3.14159265);
    float y = B * x + C * x * abs(x);
    const float P = 0.225;
    return P * (y * abs(y) - y) + y;
}

// Optional fast cosine
float fastCos(float x) { return fastSin(x + 1.5707963); }

void main() {
    uint id = gl_GlobalInvocationID.x;

    vec4 wind = windProps[id];
    float h = wind.x;    // baseHeight
    float f = wind.y;    // flexibility
    float phase = wind.z;

    vec3 pos = fixedMat4[id][3].xyz;

    // Combine simple wind waves
    float t = elapsedTime + phase;
    float wave = fastSin(t*2.0)*0.5 + fastSin(t*3.0)*0.3
               + fastSin(pos.x*0.1 + t) * fastSin(pos.z*0.1 + t*1.3)*0.8
               + fastSin(t*0.5)*1.2;

    float strength = 2.0 * wave * f;
    vec3 disp = normalize(vec3(1.0, 1.0, 0.5)) * strength * h;

    // Simple axis-angle rotation
    float tilt = clamp(length(disp)*2.0, 0.0, 1.0);
    vec3 axis = cross(vec3(0.0,1.0,0.0), normalize(disp));

    if(length(axis) < 0.001) {
        grassMat4[id] = fixedMat4[id];
        return;
    }

    axis = normalize(axis);
    float angle = tilt * 3.14159 * 0.2;

    float c = fastCos(angle);
    float s = fastSin(angle);
    float oc = 1.0 - c;

    mat3 rot;
    rot[0][0] = c + axis.x*axis.x*oc;
    rot[0][1] = axis.x*axis.y*oc - axis.z*s;
    rot[0][2] = axis.x*axis.z*oc + axis.y*s;

    rot[1][0] = axis.y*axis.x*oc + axis.z*s;
    rot[1][1] = c + axis.y*axis.y*oc;
    rot[1][2] = axis.y*axis.z*oc - axis.x*s;

    rot[2][0] = axis.z*axis.x*oc - axis.y*s;
    rot[2][1] = axis.z*axis.y*oc + axis.x*s;
    rot[2][2] = c + axis.z*axis.z*oc;

    // Apply rotation to original mat3 (assume uniform scale)
    mat3 origRot = mat3(fixedMat4[id]);
    vec3 scale = vec3(length(origRot[0]), length(origRot[1]), length(origRot[2]));
    origRot[0] /= scale.x;
    origRot[1] /= scale.y;
    origRot[2] /= scale.z;

    mat3 finalRot = rot * origRot;

    // Build mat4 with original position + scale
    mat4 result = mat4(1.0);
    result[0].xyz = finalRot[0] * scale.x;
    result[1].xyz = finalRot[1] * scale.y;
    result[2].xyz = finalRot[2] * scale.z;
    result[3].xyz = pos;

    grassMat4[id] = result;
}
