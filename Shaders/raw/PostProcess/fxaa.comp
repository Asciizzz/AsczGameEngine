#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) uniform sampler2D inputColorImage;
layout(binding = 1, rgba8) uniform writeonly image2D outputColorImage;
layout(binding = 2) uniform sampler2D depthImage;

// FXAA quality presets
#define FXAA_QUALITY_PRESET 12
#define FXAA_EDGE_THRESHOLD (1.0/3.0)
#define FXAA_EDGE_THRESHOLD_MIN (1.0/12.0)
#define FXAA_SEARCH_STEPS 16
#define FXAA_SEARCH_THRESHOLD (1.0/4.0)
#define FXAA_SUBPIX_TRIM (1.0/4.0)
#define FXAA_SUBPIX_TRIM_SCALE (1.0)
#define FXAA_SUBPIX_CAP (3.0/4.0)

// Depth-aware FXAA settings
#define DEPTH_EDGE_THRESHOLD 0.001    // Threshold for depth discontinuities
#define DEPTH_SENSITIVITY 10.0        // How much depth affects edge detection
#define MIN_DEPTH_INFLUENCE 0.1       // Minimum influence of depth on AA strength

float FxaaLuma(vec3 rgb) {
    return rgb.y * (0.587/0.299) + rgb.x;
}

// Convert NDC depth to linear depth for better depth comparison
float linearizeDepth(float depth, float near, float far) {
    float z = depth * 2.0 - 1.0; // Convert to NDC
    return (2.0 * near * far) / (far + near - z * (far - near));
}

// Calculate depth gradient to detect geometric edges
float getDepthEdgeFactor(vec2 pos, sampler2D depthTex) {
    vec2 texelSize = 1.0 / textureSize(depthTex, 0);
    float near = 0.1;
    float far = 100.0;
    
    // Sample depth at center and neighbors
    float depthC = linearizeDepth(texture(depthTex, pos).r, near, far);
    float depthN = linearizeDepth(texture(depthTex, pos + vec2(0.0, -texelSize.y)).r, near, far);
    float depthS = linearizeDepth(texture(depthTex, pos + vec2(0.0, texelSize.y)).r, near, far);
    float depthW = linearizeDepth(texture(depthTex, pos + vec2(-texelSize.x, 0.0)).r, near, far);
    float depthE = linearizeDepth(texture(depthTex, pos + vec2(texelSize.x, 0.0)).r, near, far);
    
    // Calculate depth gradients
    float gradX = abs(depthE - depthW) * 0.5;
    float gradY = abs(depthN - depthS) * 0.5;
    float depthGradient = max(gradX, gradY);
    
    // Convert to edge factor (0 = strong depth edge, 1 = no depth edge)
    return 1.0 - clamp(depthGradient * DEPTH_SENSITIVITY, 0.0, 1.0);
}

vec3 FxaaPixelShader(vec2 pos, sampler2D tex, sampler2D depthTex) {
    vec2 inverseVP = 1.0 / textureSize(tex, 0);
    
    // Get depth edge factor first - this will modulate our FXAA strength
    float depthEdgeFactor = getDepthEdgeFactor(pos, depthTex);
    
    // If we're on a strong depth edge, reduce anti-aliasing to preserve geometric details
    if (depthEdgeFactor < 0.3) {
        return texture(tex, pos).rgb; // Skip FXAA on strong depth discontinuities
    }
    
    vec3 rgbN = textureLod(tex, pos + vec2(0.0, -inverseVP.y), 0.0).rgb;
    vec3 rgbW = textureLod(tex, pos + vec2(-inverseVP.x, 0.0), 0.0).rgb;
    vec3 rgbM = textureLod(tex, pos, 0.0).rgb;
    vec3 rgbE = textureLod(tex, pos + vec2(inverseVP.x, 0.0), 0.0).rgb;
    vec3 rgbS = textureLod(tex, pos + vec2(0.0, inverseVP.y), 0.0).rgb;
    
    float lumaN = FxaaLuma(rgbN);
    float lumaW = FxaaLuma(rgbW);
    float lumaM = FxaaLuma(rgbM);
    float lumaE = FxaaLuma(rgbE);
    float lumaS = FxaaLuma(rgbS);
    
    float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));
    float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));
    float range = rangeMax - rangeMin;
    
    // Adjust edge threshold based on depth information
    float adaptiveEdgeThreshold = FXAA_EDGE_THRESHOLD * mix(2.0, 1.0, depthEdgeFactor);
    
    if (range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * adaptiveEdgeThreshold)) {
        return rgbM;
    }
    
    vec3 rgbL = rgbN + rgbW + rgbM + rgbE + rgbS;
    
    float lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25;
    float rangeL = abs(lumaL - lumaM);
    float blendL = max(0.0, (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE;
    
    // Modulate blend strength based on depth edge factor
    blendL *= mix(MIN_DEPTH_INFLUENCE, 1.0, depthEdgeFactor);
    blendL = min(FXAA_SUBPIX_CAP, blendL);
    
    vec3 rgbNW = textureLod(tex, pos + vec2(-inverseVP.x, -inverseVP.y), 0.0).rgb;
    vec3 rgbNE = textureLod(tex, pos + vec2(inverseVP.x, -inverseVP.y), 0.0).rgb;
    vec3 rgbSW = textureLod(tex, pos + vec2(-inverseVP.x, inverseVP.y), 0.0).rgb;
    vec3 rgbSE = textureLod(tex, pos + vec2(inverseVP.x, inverseVP.y), 0.0).rgb;
    
    rgbL += (rgbNW + rgbNE + rgbSW + rgbSE);
    rgbL *= vec3(1.0/9.0);
    
    float lumaNW = FxaaLuma(rgbNW);
    float lumaNE = FxaaLuma(rgbNE);
    float lumaSW = FxaaLuma(rgbSW);
    float lumaSE = FxaaLuma(rgbSE);
    
    float edgeVert = 
        abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +
        abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +
        abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));
    float edgeHorz = 
        abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +
        abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +
        abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));
        
    bool horzSpan = edgeHorz >= edgeVert;
    float lengthSign = horzSpan ? -inverseVP.y : -inverseVP.x;
    if (!horzSpan) lumaN = lumaW, lumaS = lumaE;
    
    float gradientN = abs(lumaN - lumaM);
    float gradientS = abs(lumaS - lumaM);
    lumaN = (lumaN + lumaM) * 0.5;
    lumaS = (lumaS + lumaM) * 0.5;
    
    bool pairN = gradientN >= gradientS;
    if (!pairN) lumaN = lumaS, gradientN = gradientS, lengthSign *= -1.0;
    
    vec2 posN;
    posN.x = pos.x + (horzSpan ? 0.0 : lengthSign * 0.5);
    posN.y = pos.y + (horzSpan ? lengthSign * 0.5 : 0.0);
    
    gradientN *= FXAA_SEARCH_THRESHOLD;
    
    vec2 posP = posN;
    vec2 offNP = horzSpan ? vec2(inverseVP.x, 0.0) : vec2(0.0, inverseVP.y);
    float lumaEndN = lumaN;
    float lumaEndP = lumaN;
    bool doneN = false;
    bool doneP = false;
    posN += offNP * vec2(-1.0, -1.0);
    posP += offNP * vec2( 1.0,  1.0);
    
    for (int i = 0; i < FXAA_SEARCH_STEPS; i++) {
        if (!doneN) lumaEndN = FxaaLuma(textureLod(tex, posN.xy, 0.0).rgb);
        if (!doneP) lumaEndP = FxaaLuma(textureLod(tex, posP.xy, 0.0).rgb);
        doneN = doneN || (abs(lumaEndN - lumaN) >= gradientN);
        doneP = doneP || (abs(lumaEndP - lumaN) >= gradientN);
        if (doneN && doneP) break;
        if (!doneN) posN -= offNP;
        if (!doneP) posP += offNP;
    }
    
    float dstN = horzSpan ? pos.x - posN.x : pos.y - posN.y;
    float dstP = horzSpan ? posP.x - pos.x : posP.y - pos.y;
    bool directionN = dstN < dstP;
    lumaEndN = directionN ? lumaEndN : lumaEndP;
    
    if (((lumaM - lumaN) < 0.0) == ((lumaEndN - lumaN) < 0.0)) lengthSign = 0.0;
    
    float spanLength = (dstP + dstN);
    dstN = directionN ? dstN : dstP;
    float subPixelOffset = (0.5 + (dstN * (-1.0/spanLength))) * lengthSign;
    
    vec3 rgbF = textureLod(tex, vec2(
        pos.x + (horzSpan ? 0.0 : subPixelOffset),
        pos.y + (horzSpan ? subPixelOffset : 0.0)), 0.0).rgb;
    
    // Final blend modulated by depth awareness
    float finalBlend = blendL * depthEdgeFactor;
    return mix(rgbF, rgbL, finalBlend);
}

void main() {
    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imgSize = imageSize(outputColorImage);
    
    if (texCoord.x >= imgSize.x || texCoord.y >= imgSize.y) {
        return;
    }
    
    vec2 uv = (vec2(texCoord) + 0.5) / vec2(imgSize);
    
    // Apply depth-aware FXAA
    vec3 color = FxaaPixelShader(uv, inputColorImage, depthImage);

    imageStore(outputColorImage, texCoord, vec4(color, 1.0));
}
